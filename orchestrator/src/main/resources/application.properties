spring.application.name=orchestrator
server.port=9001

spring.ai.vectorstore.pgvector.enabled=true
spring.ai.vectorstore.pgvector.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/ntg_jvm_agent}
spring.ai.vectorstore.pgvector.datasource.username=${SPRING_DATASOURCE_USERNAME:admin}
spring.ai.vectorstore.pgvector.datasource.password=${SPRING_DATASOURCE_PASSWORD:admin}

spring.ai.mcp.client.sse.connections[0].url=http://localhost:9003

spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:9000

spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/ntg_jvm_agent}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:admin}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:admin}

# The SQL dialect makes Hibernate generate better SQL for the chosen database
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.jdbc.time_zone=UTC

# Hibernate ddl auto (none, create, create-drop, validate, update)
#spring.jpa.hibernate.ddl-auto=create
spring.jpa.hibernate.show-sql=true

# change to true when you want to migrate
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true
spring.flyway.locations=classpath:db/migration/orchestrator
spring.flyway.table=flyway_schema_history_orchestrator

management.endpoints.web.exposure.include=health,metrics,prometheus,traces
management.metrics.tags.application=orchestrator

management.tracing.sampling.probability=${TRACING_SAMPLING_PROBABILITY:1.0}
management.otlp.tracing.endpoint=http://localhost:4318/v1/traces
management.otlp.tracing.protocol=http/protobuf
security.prometheus.username=${PROMETHEUS_USERNAME:prometheus}
security.prometheus.password=${PROMETHEUS_PASSWORD:password}
security.prometheus.role=${PROMETHEUS_ROLE:PROMETHEUS}

spring.ai.retry.enabled=false
spring.ai.openai.retry.enabled=false
spring.ai.openai.client.http.retry.enabled=false
spring.retry.enabled=false

# ----------------------------------------------
# SEMANTIC PROFILE
# Larger chunks for semantic coherence (PDF, docx, json, xml)
# ----------------------------------------------
chunker.profiles.semantic.chunkSize=800
chunker.profiles.semantic.minChunkSizeChars=400
chunker.profiles.semantic.minChunkLengthToEmbed=20
chunker.profiles.semantic.maxNumChunks=3000
chunker.profiles.semantic.keepSeparator=true

# ----------------------------------------------
# SENTENCE PROFILE
# Ideal for medium-sized text, customer manuals, FAQs, chat logs
# ----------------------------------------------
chunker.profiles.sentence.chunkSize=300
chunker.profiles.sentence.minChunkSizeChars=150
chunker.profiles.sentence.minChunkLengthToEmbed=5
chunker.profiles.sentence.maxNumChunks=3000
chunker.profiles.sentence.keepSeparator=true

# ----------------------------------------------
# MARKDOWN PROFILE
# Uses markdown-aware chunking for .md, .txt
# ----------------------------------------------
chunker.profiles.markdown.chunkSize=600
chunker.profiles.markdown.minChunkSizeChars=300
chunker.profiles.markdown.minChunkLengthToEmbed=10
chunker.profiles.markdown.maxNumChunks=1000
chunker.profiles.markdown.keepSeparator=true

# ----------------------------------------------
# CODE PROFILE
# Designed for programming languages with small, meaningful blocks
# ----------------------------------------------
chunker.profiles.code.chunkSize=200
chunker.profiles.code.minChunkSizeChars=100
chunker.profiles.code.minChunkLengthToEmbed=5
chunker.profiles.code.maxNumChunks=5000
chunker.profiles.code.keepSeparator=true
